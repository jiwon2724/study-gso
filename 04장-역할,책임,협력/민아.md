# 역할, 책임, 협력

> 객체지향 설계의 전체적인 품질을 결정하는 것은 개별 객체의 품질이 아니라 여러 객체들이 모여 이뤄내는 협력의 품질이다.
> 
> 객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고, 어떤 객체로부터 메세지를 수신할 것인지를 결정하는 것으로부터 시작된다. <br>
> 어떤 클래스가 필요하고 어떤 메서드를 포함해야 하는지를 결정하는 것은 책임과 메세지에 대한 대략적인 윤곽을 잡은 후에 시작해도 늦지 않다.


## 협력
> 협력은 다수의 요청과 응답으로 구성되며, 전체적으로 협력은 다수의 연쇄적인 요청과 응답의 흐름으로 구성된다.
>
> 올바른 객체를 설계하기 위해서는 먼저 견고하고 깔끔한 협력을 먼저 설계해야 한다.

- 어떤 객체가 특정 요청을 받아들일 수 있는 이유는 그 요청에 대해 적절한 방식으로 응답하는 데 필요한 지식과 행동을 가지고 있기 때문이다.
- 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.
- 어떤 대상에 대한 요청은 그 대상이 요청을 처리할 책임이 있음을 암시한다.

## 책임
> 어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있는 경우 해당 객체가 책임을 가진다고 말한다.

### 책임의 분류
- 책임은 객체에 의해 정의되는 응집도 있는 행위의 집합으로, 객체가 알아야 하는 정보와 객체가 수행할 수 있는 행위에 대해 개략적으로 서술한 문장이다.
- 즉, 객체의 책임은 `'객체가 무엇을 알고 있는가(knowing)'`와 `'무엇을 할 수 있는가(doing)'`으로 구성된다.
- 따라서 책임은 객체의 공용 인터페이스(public interface)를 구성한다.

**DOING(외부에 제공해줄 수 있는 서비스)**
- 객체를 생성하거나 계산을 하는 등 스스로 하는 것
- 다른 객체의 행동을 시작시키는 것
- 다른 객체의 활동을 제어하고 조절하는 것

**KNOWING(객체의 외부에 제공해 줄 수 있는 정보)**
- 개인적인 정보에 관해 아는 것
- 관련된 객체에 관해 아는 것
- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

## 역할
> 역할은 협력 내에서 `다른 객체로 대체할 수 있음(행위 호환성)`을 나타내는 일종의 표식이다. <br>
> 역할을 대체할 수 있는 객체는 동일한 메세지를 이해할 수 있는 객체로 한정된다. <br>
> 즉, 협력 내에서 동일한 책임의 집합을 수행할 수 있다는 것을 의미한다.

**단순성(simplicity)**
- 역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부하를 줄일 수 있다.

**유연성(flexibility)**
- 다양한 객체들이 협력에 참여할 수 있기 때문에 협력이 좀 더 유연해진다.

**재사용성(reusability)**
- 다양한 객체들이 동일한 협력에 참여할 수 있기 때문에 재사용성이 높아진다.

객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다. 따라서 대부분의 경우에 객체의 타입과 역할 사이에는 **일반화/특수화 관계**가 성립하는 것이 일반적이다.

역할이 협력을 추상적으로 만들 수 있는 이유는 역할 자체가 객체의 추상화이기 때문이다.

**협력의 추상화**
> 역할의 가장 큰 가치는 하나의 협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 협력을 추상화할 수 있다는 것이다.

ex) "왕-하얀 토끼-모자 장수" == "왕-하얀 토끼-요리사" == "여왕-하얀 토끼-앨리스" <br>
=> "판사-하얀 토끼-증인"

## 책임-주도 설계(Responsibility-Driven Design)

> 시스템의 책임을 객체의 책임으로 변환하고, 각 객체가 책임을 수행하는 중에 필요한 정보나 서비스를 제공해줄 협력자를 찾아 해당 협력자에게 책임을 할당하는 방식으로 객체들의 협력 공동체를 구축한다. <br>
> 개별적인 객체의 상태가 아니라 객체의 책임과 상호작용에 집중한다. <br>
>결과적으로 시스템은 스스로 자신을 책임질 수 있을 정도로 충분히 협조적인 객체들로 이뤄진 생테계를 구성하게 된다.

- 시스템의 기능은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 적절한 객체에게 할당된다.
- 객체가 책임을 수행하는 도중에 스스로 처리할 수 없는 정보나 기능이 필요한 경우 적절한 객체를 찾아 필요한 작업을 요청한다.
- 요청된 작업을 수행하는 일은 작업을 위임받은 객체의 책임으로 변환된다.
- 객체가 다른 객체에게 작업을 요청하는 행위를 통해 객체들 간의 협력 관계가 만들어진다.
- 만약 책임을 여러 종류의 객체가 수행할 수 있다면 협력자는 객체가 아니라 추상적인 역할로 대체된다.


## 디자인 패턴(Design Pattern)
> 전문가들이 반복적으로 사용하는 해결 방법을 정의해놓은 설계 템플릿의 모음으로, 책임-주도 설계의 결과를 표현한다.

- 일반적으로 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍으로 정의된다.
- ex) COMPOSITE PATTERN
  - 전체와 부분을 하나의 단위로 추상화해야 하는 경우 사용할 수 있는 패턴
  - 부분과 전체가 투명하고 동일한 인터페이스를 제공해야 한다는 제약 하에서 식별된 역할, 책임, 협력을 제공하는 설게 예제
- 따라서 디자인 패턴은 유사한 상황에서 반복적으로 적용할 수 있는 책임-주도 설계의 결과물

## 테스트 주도 개발(Test-Driven Development)
> 애자일 방법론의 한 종류인 XP의 기본 프랙티스로 소개되면서 주목받기 시작한 설계 기법

- 실패하는 테스트를 작성하고, 테스트를 통과하는 가장 간단한 코드를 작성한다.
- 리팩토링을 통해 중복을 제거한다.
- 이를 통해 '작동하는 깔끔한 코드'를 얻을 수 있다.
- 응집도가 높고 결합도가 낮은 클래스로 구성된 시스템을 개발할 수 있게 돕는다.

테스트 주도 개발은 테스트를 작성하는 것이 아니라, <br>
책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메세지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것이다.

- 테스트를 작성하기 위해 객체의 메서드를 호출하고 반환값을 검증하는 것은 순간적으로 객체가 수행해야 하는 책임에 관해 생각한 것이다.
- 테스트에 필요한 간접 입력 값을 제공하기 위해 스텁(stub)을 추가하거나 간접 출력 값을 검증하기 위해 목 객체(mock object)를 사용하는 것은 객체와 협력해야 하는 협력자에 관해 고민한 결과를 코드로 표현한 것이다.

# 20250122 스터디 회고
- 추상화를 하면 RDD가 강제된다.
- 화살표 방향을 request로
